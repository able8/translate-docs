# aws-controllers-k8s Code Generation

------

In order to keep the code for all the service controllers consistent, we will use a strategy of generating the custom resource definitions and controller code stubs for new AWS services.

 为了保持所有服务控制器的代码一致，我们将使用一种策略来为新的 AWS 服务生成自定义资源定义和控制器代码存根。

## Options considered

## 考虑的选项

To generate custom resource (definitions) and controller stub code, we investigated a number of options:

 为了生成自定义资源（定义）和控制器存根代码，我们研究了多种选择：

- home-grown custom code generator
 - [kudo](https://kudo.dev/)
 - [kubebuilder](https://github.com/kubernetes-sigs/kubebuilder)
 - a hybrid custom code generator + `sigs.kubernetes.io/controller-tools` (CR)



 - 自制的自定义代码生成器
- [kubebuilder](https://github.com/kubernetes-sigs/kubebuilder)
- 混合自定义代码生成器 + `sigs.kubernetes.io/controller-tools` (CR)

The original AWS Service Operator used a [custom-built generator](https://github.com/amazon-archives/aws-service-operator/tree/master/code-generation) that processed [YAML manifests](https://github.com/amazon-archives/aws-service-operator/tree/master/models) describing the AWS service and used [templates](https://github.com/amazon-archives/aws-service-operator/tree/master/code-generation/pkg/codegen/assets) to [generate CRDs](https://github.com/amazon-archives/aws-service-operator/blob/b4befd62322a57ac78aa39ea08771fc32912592a/code-generation/pkg/codegen/assets/aws-service-operator.yaml.templ#L13-L31), the [controller code](https://github.com/amazon-archives/aws-service-operator/blob/master/code-generation/pkg/codegen/assets/operator.go.templ) itself and the [Go types](https://github.com/amazon-archives/aws-service-operator/blob/master/code-generation/pkg/codegen/assets/types.go.templ) that represent the CRDs in memory. It’s worth noting that the CRDs *and* the controller code that was generated by the original ASO was very tightly coupled to CloudFormation. In fact, the CRDs for individual AWS services like S3 or RDS were thin wrappers around CloudFormation stacks that described the object being operated upon.

 最初的 AWS 服务运营商使用 [定制生成器](https://github.com/amazon-archives/aws-service-operator/tree/master/code-generation) 处理 [YAML 清单](https://github.com/amazon-archives/aws-service-operator/tree/master/models) 描述 AWS 服务和使用的[模板](https://github.com/amazon-archives/aws-service-operator/tree/master/code-generation/pkg/codegen/assets) [生成 CRD](https://github.com/amazon-archives/aws-service-operator/blob/b4befd62322a57ac78aa39ea08771fc32912592a/code-generation/pkg/codegen/assets/aws-service-operator.yaml.templ#L13-L31)，[控制器代码](https://github.com/amazon-archives/aws-service-operator/blob/master/code-generation/pkg/codegen/assets/operator.go.templ) 本身和 [Go 类型](https://github.com/amazon-archives/aws-service-operator/blob/master/code-generation/pkg/codegen/assets/types.go.templ) 表示内存中的 CRD。值得注意的是，CRD *和*由原始 ASO 生成的控制器代码与 CloudFormation 紧密耦合。事实上，用于单个 AWS 服务（如 S3 或 RDS)的 CRD 是围绕描述正在操作的对象的 CloudFormation 堆栈的薄包装器。

`kudo` is a platform for building Kubernetes Operators. It stores state in its own kudo.dev CRDs and allows users to define “plans” for a deployed application to deploy itself. We determined that kudo was not a particularly good fit for ASO for a couple reasons. First, we needed a way to generate CRDs in several API groups (s3.aws.com and iam.aws.com for example) and the ACK controller code isn’t deploying an “application” that needs to have a controlled deployment plan. Instead, ACK is a collection of controllers that facilitates creation and management of various AWS service objects using Kubernetes CRD instances.

 `kudo` 是一个用于构建 Kubernetes Operators 的平台。它将状态存储在自己的 kudo.dev CRD 中，并允许用户为已部署的应用程序定义“计划”以自行部署。由于几个原因，我们确定 kudo 不是特别适合 ASO。首先，我们需要一种在多个 API 组（例如 s3.aws.com 和 iam.aws.com）中生成 CRD 的方法，并且 ACK 控制器代码不部署需要有受控部署计划的“应用程序”。相反，ACK 是一个控制器的集合，它有助于使用 Kubernetes CRD 实例创建和管理各种 AWS 服务对象。

`kubebuilder` is the recommended upstream tool for generating CRDs and controller stub code. It is a Go binary that creates the scaffolding for CRDs and controller Go code. It has support for multiple API groups (e.g. `s3.amazonaws.com` and `dynamodb.amazonaws.com`) in a single code repository, so allows for sensible separation of code.

 `kubebuilder` 是推荐的用于生成 CRD 和控制器存根代码的上游工具。它是一个 Go 二进制文件，可以为 CRD 和控制器 Go 代码创建脚手架。它支持单个代码存储库中的多个 API 组（例如 `s3.amazonaws.com` 和 `dynamodb.amazonaws.com`），因此允许合理地分离代码。

Our final option was to build a hybrid custom code generator that used controller-runtime under the hood but allowed us to generate controller stub code for multiple API groups and place generated code [in directories](https://github.com/kubernetes-sigs/kubebuilder/issues/1268) that represented Go best practices. This option gives us the flexibility to generate the files and content for multiple API groups but still stay within the recommended guardrails of the upstream Kubernetes community.

 我们的最终选择是构建一个混合自定义代码生成器，该生成器在后台使用控制器运行时，但允许我们为多个 API 组生成控制器存根代码并将生成的代码放置在[目录中](https://github.com/kubernetes-sigs/kubebuilder/issues/1268) 代表了 Go 的最佳实践。此选项使我们能够灵活地为多个 API 组生成文件和内容，但仍保持在上游 Kubernetes 社区推荐的防护栏内。

## Our approach

##  我们的方法

We ended up with a hybrid custom+controller-runtime, using multiple phases of code generation:

 我们最终得到了一个混合的自定义+控制器运行时，使用代码生成的多个阶段：

![Multi-phase approach to code generation for ACK](https://aws-controllers-k8s.github.io/community/docs/contributor-docs/images/multi-phase-code-generation.png)

The first code generation phase consumes model information from a canonical source of truth about an AWS service and the objects and interfaces that service exposes and generates files containing code that exposes Go types for those objects. These “type files” should be annotated with the marker and comments that will allow the core code generators and controller-gen to do its work. We will use the [model files](https://github.com/aws/aws-sdk-go/tree/master/models/apis) from the [`aws-sdk-go`](https://github.com/aws/aws-sdk-go) source repository as our source of truth and use the `aws-sdk-go/private/model/api` Go package to navigate that model.

   第一个代码生成阶段使用来自有关 AWS 服务的规范真实来源的模型信息以及该服务公开的对象和接口，并生成包含公开这些对象的 Go 类型的代码的文件。这些“类型文件”应该用标记和注释进行注释，以允许核心代码生成器和 controller-gen 完成其工作。我们将使用 [`aws-sdk-go`](https://github.com/aws/aws-sdk-go) 源存储库作为我们的真实来源，并使用 `aws-sdk-go/private/model/api` Go 包来导航该模型。

  Note

   笔记

  This step is the `ack-generate apis` command.

   这一步就是`ack-generate apis`命令。

  After generating Kubernetes API type definitions for the top-level resources exposed by the AWS API, we then need to generate the “DeepCopy” interface implementations that enable those top-level resources and type definitions to be used by the Kubernetes runtime package (it defines an interface called `runtime.Object` that requires certain methods that copy the object and its component parts).

   在为 AWS API 公开的顶级资源生成 Kubernetes API 类型定义后，我们需要生成“DeepCopy”接口实现，使这些顶级资源和类型定义能够被 Kubernetes 运行时包使用（它定义一个名为 runtime.Object 的接口，它需要某些方法来复制对象及其组成部分）。

  Note

   笔记

  This step runs the `controller-gen object` command

   此步骤运行“controller-gen object”命令

  Next, we generate the custom resource definition (CRD) configuration files, one for each top-level resource identified in earlier steps.

   接下来，我们生成自定义资源定义 (CRD) 配置文件，一个用于前面步骤中确定的每个顶级资源。

  Note

   笔记

  This step runs the `controller-gen crd` command

   此步骤运行“controller-gen crd”命令

  Next, we generate the actual implementation of the ACK controller for the target service. This step uses a set of templates and code in the `pkg/model` Go package to construct the service-specific resource management and linkage with the `aws-sdk-go` client for the service. Along with these controller implementation Go files, this step also outputs a set of Kubernetes configuration files for the `Deployment` and the `ClusterRoleBinding` of the `Role` created in the next step.

   接下来，我们为目标服务生成 ACK 控制器的实际实现。此步骤使用 `pkg/model` Go 包中的一组模板和代码来构建特定于服务的资源管理以及与服务的 `aws-sdk-go` 客户端的链接。除了这些控制器实现 Go 文件，这一步还为下一步创建的 `Role` 的 `Deployment` 和 `ClusterRoleBinding` 输出一组 Kubernetes 配置文件。

  Note

   笔记

  This step runs the `ack-generate controller` command

   此步骤运行“ack-generate controller”命令

  Finally, we generate the configuration file for a Kubernetes `Role` that the Kubernetes `Pod` (running in a Kubernetes `Deployment`) running the ACK service controller. This `Role` needs to have permissions to read and write CRs of the Kind that the service controller manages.

   最后，我们为运行 ACK 服务控制器的 Kubernetes `Pod`（在 Kubernetes `Deployment` 中运行）生成 Kubernetes `Role` 的配置文件。此“角色”需要具有读取和写入服务控制器管理的 Kind CR 的权限。

  Note

   笔记

  This step runs the `controller-gen rbac` command

   此步骤运行“controller-gen rbac”命令

  ### Crossplane Provider Generation

   ### 跨平面供应商生成

  We have experimental support for generating API types and controller code for AWS services to be used in Crossplane AWS Provider. To try it out, you can run the following command:

   我们实验性地支持为 AWS 服务生成 API 类型和控制器代码，以便在 Crossplane AWS Provider 中使用。要尝试一下，您可以运行以下命令：

  ```
   go run -tags codegen cmd/ack-generate/main.go crossplane ecr --provider-dir <directory for provider>
  cd <directory for provider>
  go generate ./...
  ```

  [Edit this page on GitHub](https://github.com/aws-controllers-k8s/community/blob/main/docs/content/docs/contributor-docs/code-generation.md)

​     [在 GitHub 上编辑此页面](https://github.com/aws-controllers-k8s/community/blob/main/docs/content/docs/contributor-docs/code-generation.md)

​    https://aws-controllers-k8s.github.io/community/docs/contributor-docs/code-generation/

   https://aws-controllers-k8s.github.io/community/docs/contributor-docs/code-generation/



