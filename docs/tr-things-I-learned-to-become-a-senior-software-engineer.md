# Things I Learned to Become a Senior Software Engineer

# 成为高级软件工程师后我学到的东西

      Sep 6, 2020                    •                   [Tech](https://neilkakkar.com/categories/#Tech)                In 2018, I started working at Bloomberg. Things have changed a  lot since. I’m not the most junior member in the company anymore and  I’ve mentored quite a few new engineers, which has been amazing. It  helped me observe how others differ from me, absorb their best  practices, and figure out things I’ve unconsciously been doing pretty  well.

2020 年 9 月 6 日 • [Tech](https://neilkakkar.com/categories/#Tech) 2018 年，我开始在彭博社工作。从那以后，情况发生了很大变化。我不再是公司里最年轻的成员了，我指导了很多新工程师，这真是太棒了。它帮助我观察其他人与我的不同之处，吸收他们的最佳实践，并找出我在不知不觉中做得很好的事情。

Yearly work reviews are a good way to condense these lessons I’ve  learned. They’re valuable for pattern matching, too. Only when I zoom  out do certain patterns become visible. I can then [start tracking these patterns consciously](https://neilkakkar.com/the-human-log.html).

年度工作回顾是浓缩我学到的这些经验教训的好方法。它们对于模式匹配也很有价值。只有当我缩小时，某些图案才会变得可见。然后我可以[开始有意识地跟踪这些模式](https://neilkakkar.com/the-human-log.html)。

The broad theme for this year is zooming out and challenging the  boundaries. It’s also about zooming in, and adding nuance to the  sections from last year. It’s more fun if you’ve [read last year’s review first](https://neilkakkar.com/things-I-learnt-from-a-senior-dev.html): You can then diff my growth.

今年的广泛主题是缩小和挑战界限。这也是关于放大，并为去年的部分添加细微差别。如果你[先阅读去年的评论](https://neilkakkar.com/things-I-learnt-from-a-senior-dev.html)，那就更有趣了：然后你可以区分我的成长。

It all began with a question: How do I grow further?

这一切都始于一个问题：我如何进一步成长？

## Growing using different ladders of abstraction

## 使用不同的抽象阶梯增长

Entering my second year, I had all the basics in place. I had picked  all the low hanging fruit, and my rate of growth slowed down. Not good. The big question in my mind was “How do I grow further?”

进入第二年，我已经掌握了所有基础知识。我已经摘下了所有悬而未决的果实，我的增长速度放缓了。不好。我心中最大的问题是“我如何进一步成长？”

There was only so much I could do to improve my coding skills. Most  blogs epousing techniques to write cleaner code, repeating yourself, not repeating yourself, etc. are micro-optimisations. Almost none of them  would make me instantly impactful.

我能做的只有这么多来提高我的编码技能。大多数博客采用技术来编写更清晰的代码，重复自己，不重复自己等等，都是微优化。几乎没有一个能让我立即产生影响。


However, I did figure out something insightful. I’m working inside  the software development lifecycle, but this lifecycle is part of a  bigger lifecycle: the product and infrastructure development lifecycle. I decided to go broader instead of deeper. Surprisingly, the breadth  provided more depth to what I knew.


不过，我确实想出了一些有见地的东西。我在软件开发生命周期内工作，但这个生命周期是更大生命周期的一部分：产品和基础设施开发生命周期。我决定更广泛而不是更深入。令人惊讶的是，广度为我所知道的提供了更多的深度。

I zoomed out in 3 broad directions: learning what people around me  are doing, learning good habits of mind, and acquiring new tools for  thought.

我在 3 个广泛的方向上进行了放大：了解我周围的人在做什么，学习良好的思维习惯，以及获得新的思考工具。

## Learning what people around me are doing

## 了解我周围的人在做什么

Since we’re not in a closed system, it makes sense to better  understand the job of the product managers, the sales people, and the  analysts. In the end it’s a business making money through products. The  goal isn’t to write code, it’s to be a profitable business.

由于我们不在一个封闭的系统中，因此更好地了解产品经理、销售人员和分析师的工作是有意义的。归根结底，这是一家通过产品赚钱的企业。我们的目标不是编写代码，而是成为一项有利可图的业务。


Most big companies aren’t doing just one thing, which means there are different paths to making money in the same company. Everyone is on at  least one path - if they weren’t, they wouldn’t be here.


大多数大公司不只做一件事，这意味着在同一家公司有不同的赚钱途径。每个人都至少走一条路——如果没有，他们就不会在这里。


  Tracking these paths, and the path I’m on was  pretty valuable. It helped me see how I matter, and what levers I can  pull to become more effective. Sometimes, it’s about making the sales  jobs easier, so they can make more sales. Other times, it’s about  building a new feature for clients. And some other times, it’s about  improving a feature that keeps breaking.


 跟踪这些路径，以及我所走的路径非常有价值。它帮助我了解我的重要性，以及我可以拉动哪些杠杆来变得更有效。有时，这是为了让销售工作更轻松，以便他们可以进行更多的销售。其他时候，则是为客户构建新功能。有时，它是关于改进一个不断破坏的功能。

Product managers are the best source for this. They know how the  business makes money, who are the clients, and what do clients need.

产品经理是最好的来源。他们知道企业如何赚钱，谁是客户，以及客户需要什么。

Over the year, I setup quite a few meetings with everyone on my path. A second benefit this gave me was the context of other’s jobs. It  helped me communicate better. Framing things in the right way is  powerful.

一年来，我与路上的每个人都安排了很多会议。这给我的第二个好处是其他人的工作背景。它帮助我更好地沟通。以正确的方式构建事物是强大的。

For example, one conversation helped me appreciate why Sarah in Sales wants a bulk update tool. Some companies have lots of employees, and   updating them one by one is a pain. The code I write would literally  ease Sarah’s pain.

例如，一次谈话帮助我理解了为什么 Sales 的 Sarah 想要一个批量更新工具。有的公司员工很多，一个一个更新很痛苦。我写的代码确实可以减轻莎拉的痛苦。

## Learning good habits of mind

## 学习良好的心态

Software engineering entails thinking well and making the right decisions. Programming is implementing those decisions.

软件工程需要好好思考并做出正确的决定。编程正在实施这些决定。

A habit of mind is something your brain does regularly. This could be thinking of X whenever you see Y happen, or applying thinking tool X to problem Y. In short, habits of mind facilitate better thinking.

思维习惯是你的大脑经常做的事情。这可以是当你看到 Y 发生时就想到 X，或者将思维工具 X 应用于问题 Y。简而言之，思维习惯有助于更好地思考。

I suspected if I learn the general skill, I should be able to apply it better to software engineering.

我怀疑如果我学习了通用技能，我应该能够更好地将其应用到软件工程中。

### Thinking Well

### 好好思考

Software engineering is an excellent field to practice thinking well  in. The feedback loops are shorter, and gauging correctness doesn’t take too long. 

软件工程是一个很好的练习思考的领域。反馈循环更短，衡量正确性不会花费太长时间。

I dived into cognitive science studies. It’s a permanent skill that’s worth exploring - a force multiplier for whatever I end up doing, and  pays dividends throughout my life. One output was [a framework for critical thinking](https://neilkakkar.com/Bayes-Theorem-Framework-for-Critical-Thinking.html). It’s compounding, [and compounding is powerful](https://neilkakkar.com/year-in-review-2019.html#compounding-is-powerful-building-intuition-for-compounding-even-more-so).

我潜心研究认知科学研究。这是一项值得探索的永久技能——无论我最终做什么，都是一种力量倍增器，并在我的一生中带来红利。一个输出是[批判性思维框架](https://neilkakkar.com/Bayes-Theorem-Framework-for-Critical-Thinking.html)。它是复合的，[复合是强大的](https://neilkakkar.com/year-in-review-2019.html#compounding-is-powerful-building-intuition-for-compounding-even-more-so)。

There’s lots of good things that came out of this, which I’ll talk about in a bit. They deserve their own section.

从中产生了很多好东西，我将在稍后讨论。他们值得拥有自己的部分。

### Strategies for making day-to-day more effective

### 使日常工作更有效的策略

The other side of the coin is habits that allow you to think well. It starts with noticing little irritations during the day, inefficiencies  in meetings, and then figuring out strategies to avoid them. These  strategic improvements are underrated.

硬币的另一面是让你好好思考的习惯。它首先注意到白天的小烦恼、会议效率低下，然后找出避免它们的策略。这些战略改进被低估了。

You decide what to do, and then let it run on automatic, freeing up  the brain to think of more fun stuff. Of course, that’s what a habit is, too.

你决定要做什么，然后让它自动运行，解放大脑去想更多有趣的事情。当然，这也是一种习惯。

Some good habits I’ve noticed:

我注意到的一些好习惯：

- Never leave a meeting without making the decision / having a next action
- Decide who is going to get it done. Things without an owner rarely get done.
- Document design decisions made during a project

- 永远不要在没有做出决定/没有下一步行动的情况下离开会议
- 决定谁来完成它。没有主人的事情很少能完成。
- 记录项目期间做出的设计决策

This pattern became visible during the review, so I’m keen to pay  attention and collect more strategies next year. Having an excellent  scrum master who holds me accountable has helped me get better at  following these strategies.

这种模式在审查期间变得明显，所以我很想在明年关注并收集更多策略。拥有一位让我负责的优秀 Scrum 主管帮助我更好地遵循这些策略。

## Acquiring new tools for thought & mental models

## 获得新的思维和心理模型工具

New tools for thought are related to thinking well, but more specific to software engineering. Tools for thought help me think better about  specific engineering problems.

新的思考工具与良好的思考有关，但更特定于软件工程。思维工具帮助我更好地思考特定的工程问题。

I’ve adopted a just-in-time approach to this. I look for new tools  only when I get stuck on something, or when I find out my abstractions  and design decisions aren’t working well.

我对此采取了及时的方法。只有当我陷入困境，或者当我发现我的抽象和设计决策效果不佳时，我才会寻找新工具。

For example, I was recently struggling with a domain with lots of  complex business logic. Edge cases were the norm, and we wanted to  design a system that handles this cleanly. That’s when I read about [Domain Driven Design](https://amzn.to/2FdCYUQ)

例如，我最近在一个包含大量复杂业务逻辑的域中苦苦挣扎。边缘情况是常态，我们想设计一个系统来处理这个问题。那时我读到了[领域驱动设计](https://amzn.to/2FdCYUQ)


. I could instantly put it to practice and make a  big difference. Subsequently, I grasped these concepts better. I  acquired a new mental model of how to create enterprise software.


.我可以立即将其付诸实践并产生重大影响。随后，我更好地掌握了这些概念。我获得了如何创建企业软件的新思维模型。

The second way I keep learning and acquiring new mental models is via reading what surfaces on Hacker News. They are interesting ideas, some  of which I’ve put to practice, but this is a lot less effective than the technique above. The only reason I still do this is to [map the territory](https://neilkakkar.com/rationality.html#map-and-the-territory) - it keeps me aware of techniques that exist, so when I face a problem, I know there's a method that might help.

我不断学习和获取新思维模型的第二种方式是阅读 Hacker News 上的内容。它们是有趣的想法，其中一些我已经付诸实践，但这远不如上述技术有效。我仍然这样做的唯一原因是[绘制领土](https://neilkakkar.com/rationality.html#map-and-the-territory) - 它让我了解现有的技术，所以当我面对问题，我知道有一种方法可能会有所帮助。

The final way I acquire better mental models is by learning new  diverse languages. The diversity bit is important. Learning yet another  dialect of lisp has a lot less benefit than say, learning C++03, a  functional programming language, a dynamic typed language, and a lisp. Today, [J seems interesting](https://www.hillelwayne.com/post/j-notation/), and one I might consider learning. It’s a thinking model I haven’t used before.

我获得更好心智模型的最后一种方法是学习新的不同语言。多样性位很重要。学习 lisp 的另一种方言比学习 C++03、函数式编程语言、动态类型语言和 lisp 的好处要少得多。今天，[J 看起来很有趣](https://www.hillelwayne.com/post/j-notation/)，我可能会考虑学习。这是我以前没有使用过的思维模型。

I’ve gotten lots of value from doing this. Each language has its own vocabulary and grammar, and [vocabulary is a meta-mental model](https://neilkakkar.com/vocabulary-mental-model.html). It’s a new lens to look at how to do things. 

我从这样做中获得了很多价值。每种语言都有自己的词汇和语法， [词汇是元心智模型](https://neilkakkar.com/vocabulary-mental-model.html)。这是一个看待如何做事的新镜头。

When memory management is in your control, you understand how  pointers and allocators work. When Python then abstracts this away, you  appreciate the complexity reduction. When maps and filters in a  functional language show up, you appreciate how Python’s for loops can  be improved. Indeed, that’s what list comprehensions are. And then you  notice how some things are easier with object oriented programming. There’s no one magic tool that fits everything well. And then you  understand that despite this, you don’t have to switch tools. You can  adapt best practices from one into another to solve your problems: like  writing functional javascript. It’s the principles that matter more than their expression.

当内存管理在您的控制之下时，您就会了解指针和分配器的工作原理。当 Python 将其抽象出来时，您会欣赏到复杂性的降低。当函数式语言中的映射和过滤器出现时，您会欣赏如何改进 Python 的 for 循环。事实上，这就是列表推导式。然后您会注意到使用面向对象编程使某些事情变得更容易。没有一种神奇的工具可以适合所有情况。然后您就会明白，尽管如此，您不必切换工具。您可以将最佳实践从一种应用到另一种来解决您的问题：例如编写函数式 javascript。原则比表达更重要。

        !Broadly, that’s all I did this year. What follow are insights that sprang forth thanks to zooming out.

！总的来说，这就是我今年所做的一切。接下来是由于缩小而产生的见解。

## Protect your slack

## 保护你的懈怠

When I say slack, I don’t mean the company, but the adjective.

当我说 slack 时，我指的不是公司，而是形容词。

One thing that gives me high output and productivity gains is to “slow down”. Want to get more done? Slow down.

给我带来高产出和生产力收益的一件事是“放慢速度”。想要完成更多工作？慢一点。

Caveats apply, but here’s what I mean:

注意事项适用，但我的意思是：

I’ve noticed people rush to solve problems. It can be something  they’ve done before, or something we have a template for. It feels  pretty good to smash through things. I’ve done that before, too! However, there’s very specific cases where this makes sense.

我注意到人们急于解决问题。这可能是他们以前做过的事情，或者我们有模板的事情。砸东西的感觉真好。我以前也这样做过！但是，在非常特殊的情况下，这是有意义的。


Whenever I’m working on something new, I take the time to learn  things about the system I’m working on, and things closely related to  it. If it’s too massive, I optimise for learning as much as I can. Every time I revisit the system, I aim to learn more.


每当我从事新事物时，我都会花时间了解我正在研究的系统以及与其密切相关的事物。如果它太大，我会尽可能多地优化学习。每次我重新访问系统时，我的目标是了解更多。

When [there is slack](https://www.lesswrong.com/posts/yLLkWMDbC9ZNKbjDG/slack), you get a chance to experiment, learn, and think things through. This means you get enough time to get things done.

当 [有松弛](https://www.lesswrong.com/posts/yLLkWMDbC9ZNKbjDG/slack) 时，您就有机会进行实验、学习和思考问题。这意味着您有足够的时间来完成工作。

When there is no slack, deadlines are tight, and all your focus goes into getting shit done.

当没有任何懈怠时，截止日期很紧迫，你所有的注意力都集中在完成工作上。

Protecting your slack means not letting deadlines wrap tight around you. Usually, this is as simple (or hard) as communicating.

保护您的懈怠意味着不要让截止日期紧紧围绕您。通常，这与沟通一样简单（或困难）。


Slack might have a negative connotation with “slackers”, but  protecting slack is a super power. It’s a long term investment into  building yourself up at the cost of short term efficiency.


Slack 可能带有“懒鬼”的负面含义，但保护 slack 是一种超能力。这是一项以短期效率为代价建立自己的长期投资。

When I’m quickly dishing out stories, I also have a much harder time  fixing bugs. I don’t take the time to create proper mental models of the system, which means my assumptions don’t match the code, and this  mismatch is where most bugs lie.

当我快速发布故事时，我也很难修复错误。我没有花时间为系统创建正确的心智模型，这意味着我的假设与代码不匹配，而这种不匹配正是大多数错误所在。

I protect my slack, so I can take the time out to prioritise learning things over doing things.

我保护自己的懈怠，所以我可以花时间把学习放在优先考虑做事上。


One of my favourite use cases for slack is experimentation. Sometimes, I’ll find a bug that makes zero sense to me. I notice I’m  confused, find an answer on Stack Overflow, and continue. However, this  keeps bugging me until I understand the bug. Stack Overflow answered it, but didn’t explain what was wrong in my understanding. To build up my  understanding, I need to experiment.


我最喜欢的 slack 用例之一是实验。有时，我会发现一个对我来说意义为零的错误。我注意到我很困惑，在 Stack Overflow 上找到答案，然后继续。然而，这一直困扰着我，直到我理解了这个错误。 Stack Overflow 回答了它，但没有解释我的理解有什么问题。为了建立我的理解，我需要进行实验。

If I have no slack, I have no time to experiment, which means I have  to forget about the bug. When there’s slack, I can run experiments to  find out exactly what was missing from my understanding. I love moments  like these, when I uncover something new about the system. It makes me a lot more effective the next time around.

如果我没有懈怠，我就没有时间进行实验，这意味着我必须忘记错误。当有松懈时，我可以运行实验来准确找出我的理解中遗漏了什么。我喜欢这样的时刻，当我发现系统的新事物时。这让我下次更有效率。

## Ask Questions

##  问问题

We’re generally bad at asking questions. Either we fear they’ll make  us look dumb, so we don’t ask them at all, or we ask them with long  preambles that’s more about how we’re not dumb, rather than learning  more about the thing.

我们通常不善于提问。要么我们担心他们会让我们看起来很愚蠢，所以我们根本不问他们，要么我们问他们很长的序言，更多的是关于我们如何不愚蠢，而不是更多地了解这件事。

The thing is, you can’t judge a question as dumb until you figure out the answer. The way I get around this is to declare I’ll ask lots of  questions. This frees me up to start from the bottom and patch the holes in my understanding. A positive team culture helps, too.

问题是，在你找出答案之前，你不能判断一个问题是愚蠢的。我解决这个问题的方法是声明我会问很多问题。这让我可以从底部开始，修补我理解中的漏洞。积极的团队文化也有帮助。

For example, here’s my journey learning about packaging software:

例如，这是我学习打包软件的旅程：

Q: What is a package?
  A: It’s code wrapped together that can be installed on a system. 

问：什么是包裹？
 A：是打包在一起的代码，可以安装到系统上。

Q: Why do I need packages? A: They give a consistent way of getting all the files you need in the  right place. Without them, things are easy to mess up. You need to  ensure every file is where it’s supposed to be, the system paths are set up, and dependent packages are available.

问：为什么我需要包裹？答：它们提供了一种将您需要的所有文件放在正确位置的一致方式。没有它们，事情很容易搞砸。您需要确保每个文件都在它应该在的位置，设置了系统路径，并且依赖包可用。

Q: How do packages differ from applications I can install on my  system? A: It’s a very similar idea! Windows installer is like a package manager that helps install applications. Similarly, DPKG and rpm packages are  like `.exe`s that you can install on Linux systems, with the help of `apt` and `yum` package managers, which are like the windows installers.

问：软件包与我可以在系统上安装的应用程序有何不同？ A：这是一个非常相似的想法！ Windows 安装程序就像一个帮助安装应用程序的包管理器。类似地，DPKG 和 rpm 包就像 `.exe` 一样，你可以在 `apt` 和 `yum` 包管理器的帮助下安装在 Linux 系统上，它们就像 Windows 安装程序一样。

Q: I see. So, this `setup.py` in python somehow converts into a `dpkg`? How does that work? A: We have a python-debhelper that runs `setup.py` for the conversion.

问：我明白了。那么，python 中的这个 `setup.py` 以某种方式转换为 `dpkg`？这是如何运作的？答：我们有一个 python-debhelper，它运行 `setup.py` 来进行转换。

Q: Oh, how very interesting! How did you figure this out? A: The `debian/rules` file contains instructions on how to create a `dpkg`. I looked at it to figure this out.

问：哦，多么有趣啊！你是怎么想出来的？ A: `debian/rules` 文件包含如何创建 `dpkg` 的说明。我看着它来弄清楚这一点。

Then I know it’s time for me to look at the documentation. I have  enough pieces to make sense of the outline. Turns out, this wasn’t as  simple as I thought, and it wasn’t a dumb question to ask.

然后我知道是时候查看文档了。我有足够的碎片来理解大纲。事实证明，这并不像我想象的那么简单，也不是一个愚蠢的问题。

This is a habit of mind I’ve cultivated, and there are some good  questions you can always ask. Most of them are context-dependent, but I  do have one favourite general question.

这是我养成的一种心态，有一些很好的问题可以随时问。他们中的大多数都依赖于上下文，但我确实有一个最喜欢的一般问题。

It’s called playing the meta: How did you find out X?

这叫做玩meta：你是怎么找到X的？

When I ask someone something, and they answer it, the next thing I  ask is how did they figure it out? That helps me do it myself the next  time around. I did this above, which taught me about the `debian/rules` file and how it works.

当我问某人某事，他们回答时，我接下来要问的是他们是如何弄明白的？这有助于我下次自己做。我在上面做了这个，它教会了我关于 `debian/rules` 文件以及它是如何工作的。

Another good question is to ask about what confuses you.

另一个好问题是询问什么让你感到困惑。


## Noticing Confusion


## 注意混乱

One fine day, I was working with datetimes in Python. These were  dates our search engine would index, and we wanted them in UTC. So, I  modified our pipeline to convert dates to UTC before ingestion. This  required making these dates timezone-aware.

有一天，我在 Python 中处理日期时间。这些是我们的搜索引擎将索引的日期，我们希望它们采用 UTC。因此，我修改了我们的管道以在摄取之前将日期转换为 UTC。这需要使这些日期具有时区意识。

I created a datetime like this:

我创建了一个这样的日期时间：

```
import datetime
from pytz import timezone

indexed_date = datetime.datetime(2019, 11, 20, 12, 2, 0, tzinfo=timezone('Asia/Kolkata'))
```


In my tests, this conversion was off by 23 minutes. I didn’t notice  it at the time, but seeing this confused me. So, I modified the test  offset to -23 minutes, so the tests would pass.

在我的测试中，这种转换延迟了 23 分钟。当时我没有注意到它，但看到这一点让我感到困惑。因此，我将测试偏移量修改为 -23 分钟，以便测试通过。

It’s… a pretty shitty way of thinking. Once I noticed this, I  couldn’t un-see it. It sometimes still haunts me that I let this pass.

这是……一种非常糟糕的思维方式。一旦我注意到这一点，我就无法取消它。有时，我让这件事过去了，这仍然困扰着我。

Of course, someone commented on the PR with “this looks wrong” - which *jerked* me out of my default thinking, to actually figure out what went wrong here.

当然，有人在 PR 上评论说“这看起来不对”——这让我*猛地*摆脱了我的默认想法，真正弄清楚这里出了什么问题。

It’s a pretty epic bug. Pytz has timezone information throughout  ages. Before 1942, the timezone for Asia/Calcutta was +5:53:20. (Yes,  even the city name was different). When pytz timezones are passed into a new date, there’s no reference date to match the timezone to the year. So, it defaults to the first available timezone - which is wrong. [The docs mention this, too.](https://stackoverflow.com/questions/6410971/python-datetime-object-show-wrong-timezone-offset) The right way is to use `tzinfo.localize()`, which matches the date to the appropriate timezone, since it's pytz which is now doing the conversion.

这是一个非常史诗般的错误。 Pytz 拥有各个年龄段的时区信息。 1942 年之前，亚洲/加尔各答的时区是 +5:53:20。 （是的，甚至城市名称也不同）。当 pytz 时区传递到新日期时，没有参考日期将时区与年份匹配。因此，它默认为第一个可用时区 - 这是错误的。 [文档也提到了这一点。](https://stackoverflow.com/questions/6410971/python-datetime-object-show-wrong-timezone-offset)正确的方法是使用`tzinfo.localize()`，它将日期与适当的时区相匹配，因为它是 pytz 正在执行转换。

```
import datetime
from pytz import timezone

tz=timezone('Asia/Kolkata')
indexed_date = tz.localize(datetime.datetime(2019, 11, 20, 12, 2, 0))
```


I wouldn’t have found out about this if that PR review didn’t trigger me. It exposed this scary mode of thinking where I push confusion under the rug. I’ve been wary ever since.

如果公关审查没有触发我，我就不会发现这一点。它暴露了这种可怕的思维方式，我将混乱推到了地毯下。从那以后我就很小心了。

To stop this from happening again, I’ve started training my “noticing muscles”. This is called noticing confusion. Not just when writing  code, but with everything, there’s a tendency to explain away confusion, pushing it under the rug.

为了防止这种情况再次发生，我开始训练我的“注意肌肉”。这称为注意混淆。不仅仅是在编写代码时，而且在所有事情中，都有一种解释混乱的倾向，将其推到地毯下。

Every time you hear something that sounds weird, and you rush to explain why it *must* be true, you’re pushing confusion under the rug. I’ve written [more about this here](https://neilkakkar.com/rationality.html#noticing-confusion).

每次你听到一些听起来很奇怪的东西，你急于解释为什么它*必须*是真的，你是在把困惑推到地毯下。我已经写过[更多关于这方面的内容](https://neilkakkar.com/rationality.html#noticing-confusion)。

Once you start noticing confusion, you can ask questions about what  confuses you. That might have sounded trite in the previous section, but I hope this context helps. The tricky bit is noticing what confused  you.

一旦你开始注意到困惑，你就可以问一些让你困惑的问题。在上一节中，这可能听起来很陈词滥调，但我希望此上下文有所帮助。棘手的一点是注意到是什么让你感到困惑。

## Force multipliers

## 强制乘数

One fine sprint, I accidentally felt the power of the Force. 

一次美好的冲刺，不经意间感受到了原力的威力。

> the Force is what gives a Jedi his power. It’s an energy field  created by all living things. It surrounds us and penetrates us; it  binds the galaxy together.
>  ―Obi-Wan Kenobi

> 原力赋予绝地力量。这是一个由所有生物创造的能量场。它围绕着我们，渗透着我们；它把银河系在一起。
> ―欧比旺·克诺比

I think Obi Wan Kenobi was onto something, albeit in the wrong  domain. It’s something I can leverage in software engineering: becoming a force multiplier.

我认为 Obi Wan Kenobi 做了一些事情，尽管在错误的域中。这是我可以在软件工程中利用的东西：成为一个力量倍增器。

That sprint I didn’t get much done *myself*. I wrote very  limited code. Instead, I co-ordinated which changes should go out when  (it was a complicated sprint), tested they worked well, did lots of code reviews, made alternate design suggestions, and pair-programmed  wherever I could to get things un-stuck. We got everything done, and in  this case, zooming out helped make decisions for PRs easier. It was one  of our highest velocity sprints.

那个冲刺我没有做太多*我自己*。我写的代码非常有限。相反，我协调了哪些更改应该在（这是一个复杂的冲刺）时进行，测试它们是否工作良好，进行了大量代码审查，提出了替代设计建议，并尽可能地进行结对编程以解决问题。我们完成了所有工作，在这种情况下，缩小有助于使 PR 的决策更容易。这是我们速度最快的冲刺之一。

> the Force is what gives an engineer his power. It’s an energy field created by all things. It surrounds us and penetrates us; it binds the  code together.
>  -Neil Kakkar

> 原力赋予工程师权力。这是一个由万物创造的能量场。它围绕着我们，渗透着我们；它将代码绑定在一起。
> -尼尔·卡卡

Alright, I won’t stretch this analogy further.

好吧，我不会进一步扩展这个类比。

Figuring out how to become a force multiplier sounds more valuable to me than a 10x developer. In practice, a good force multiplier (or  divider) is the team culture.

弄清楚如何成为一个力量倍增器对我来说听起来比 10 倍开发人员更有价值。在实践中，一个好的力量倍增器（或分割器）是团队文化。

Just like I can create habits of mind to multiply my output, so can  the entire team. This happens with the team culture. Retrospectives,  reviews, and experiments are everything a team does to mould their  culture. The culture is always in flux, as team members come and go,  adding their personal touches.

就像我可以创造思维习惯来增加我的产出一样，整个团队也可以。这发生在团队文化中。回顾、回顾和实验是一个团队为塑造他们的文化所做的一切。文化总是在不断变化，团队成员来来去去，加入他们的个人风格。

A culture that empowers is a force multiplier. I was able to do what I did above because our culture allowed it. Our team culture looks at the team’s output for the sprint, not the individual outputs. This allowed  me to optimise for the team getting lots done, instead of focusing on  myself.

一种赋予权力的文化是一种力量倍增器。我能够做我上面所做的，因为我们的文化允许它。我们的团队文化着眼于团队在冲刺中的输出，而不是个人输出。这让我能够优化团队完成大量工作，而不是专注于自己。

The team shapes the culture, and the culture shapes the team.

团队塑造文化，文化塑造团队。

This idea even extends to cities and nations:

这个想法甚至延伸到城市和国家：

> A society that is under constant military threat will have a  culture that celebrates martial virtues, a society that features a  cooperative economy will strongly stigmatize laziness, an egalitarian  society will treat bossiness as a major personality flaw, an industrial  society with highly regimented work schedules will prize punctuality,  and so on. - [Why the Culture Wins](https://www.sciphijournal.org/index.php/2017/11/12/why-the-culture-wins-an-appreciation-of-iain-m-banks/)

> 一个不断受到军事威胁的社会将拥有崇尚武德的文化，一个以合作经济为特色的社会将强烈谴责懒惰，一个平等主义的社会将把专横视为主要的人格缺陷，一个具有高度管制的工作时间表的工业社会会重视守时，等等。 - [为什么文化获胜](https://www.sciphijournal.org/index.php/2017/11/12/why-the-culture-wins-an-appreciation-of-iain-m-banks/)

## On Ownership

## 关于所有权

We’re 3 teams at BNEF, and we share a Jenkins setup for automated  testing. There was a big Jenkins maintenance task upcoming, and I chose  to own it. This meant figuring out how to do things, arranging meetings  to discuss improvements and alternatives, and finally, coordinating  implementation.

我们在 BNEF 有 3 个团队，我们共享一个 Jenkins 设置来进行自动化测试。即将有一项大型 Jenkins 维护任务，我选择拥有它。这意味着弄清楚如何做事，安排会议讨论改进和替代方案，最后协调实施。

Except, I didn’t know I’ll be doing all that when I chose to own it. I just thought it would be fun.

除了，当我选择拥有它时，我不知道我会做这一切。我只是觉得这会很有趣。

I messaged on our group chat about alternatives I had come up with. The conversation soon died, possibly because everyone was busy with  something. I noticed feeling “I don’t know what I’m supposed to do here  now”. So I decided to get on with my other sprint tasks.

我在我们的群聊中就我提出的替代方案发了消息。谈话很快就结束了，可能是因为每个人都在忙着什么。我注意到感觉“我不知道我现在应该在这里做什么”。所以我决定继续我的其他冲刺任务。

My instinct here went “oh well, I tried. Someone will reply someday and then we can continue the conversation”. I had [played the role](https://neilkakkar.com/rationality.html#roleplaying) of the owner, without becoming the owner.

我的直觉是“哦，好吧，我试过了。总有一天会有人回复，然后我们可以继续对话”。我[扮演了这个角色](https://neilkakkar.com/rationality.html#roleplaying) 的所有者，但没有成为所有者。

I was surprised when I noticed this. It was a hilariously bad way of managing. Everyone is working on something, and *that* is what they’re thinking about, not my stuff. So, it’s my responsibility to bring their attention to it.

当我注意到这一点时，我很惊讶。这是一种非常糟糕的管理方式。每个人都在做某事，*那*是他们在想什么，而不是我的东西。所以，我有责任引起他们的注意。

Two days after the initial chat (that’s how long it took me to  reflect and figure out I was in the wrong), I messaged again explaining  what I decided, and what work will spill over to which team. This was  the second time I was surprised: everyone agreed. It wasn’t that they  didn’t care, it’s just that they had nothing more to add after the first chat.

在最初的聊天两天后（我花了多长时间反思并发现我错了），我再次发消息解释我的决定，以及哪些工作将转移到哪个团队。这是我第二次感到惊讶：每个人都同意。不是他们不在乎，只是第一次聊天后，他们没有什么可以补充的了。

I cherish this experience a lot. It taught me some important habits:  always follow up, and if you own a task, it’s your responsibility to  move it forward. Don’t get stuck playing the role, actually get shit  done: be it by delegating or doing it yourself. 

我非常珍惜这次经历。它教会了我一些重要的习惯：始终跟进，如果你拥有一项任务，你就有责任推进它。不要沉迷于扮演这个角色，真正把事情做好：无论是委派还是自己做。

It also reinforced a meta habit: cherish surprise. Surprise is a  measure of mismatch between what you predicted and what actually  happened. This is a brilliant opportunity to [change your mind](https://neilkakkar.com/Bayes-Theorem-Framework-for-Critical-Thinking.html).

它还强化了一个元习惯：珍惜惊喜。惊喜是你预测的和实际发生的不匹配的衡量标准。这是[改变主意](https://neilkakkar.com/Bayes-Theorem-Framework-for-Critical-Thinking.html)的绝佳机会。

## Embrace fear

## 拥抱恐惧

Okay, one final story. Last year, I worked on a [side project that failed](https://neilkakkar.com/quickreps.html). It was one of those projects where I learn a new language, a new way of doing things, and test a product hypothesis. It was surprisingly  difficult to stick to the project - I felt fear whenever I’d think about it.

好的，最后一个故事。去年，我参与了一个[失败的副项目](https://neilkakkar.com/quickreps.html)。这是我学习一门新语言、一种新的做事方式并测试产品假设的项目之一。坚持这个项目出奇地困难——每当我想到它时，我就会感到恐惧。

This was a huge ball of feelings I couldn’t ignore. It primed me to  notice subtler pangs of the same feeling, specially at work. Whenever  there’s a daunting task ahead of me and I don’t already know how to do  it, this feeling creeps back. “Ugh, how would this work? I have no idea  yet.”

这是一个我无法忽视的巨大感情。它让我注意到同样感觉的更微妙的痛苦，特别是在工作中。每当有一项艰巨的任务摆在我面前并且我不知道该怎么做时，这种感觉就会慢慢回来。 “呃，这怎么操作？我还没有想法。”

I’ve learned to embrace this feeling. It excites me. It’s information about what I’m going to learn. I’ve taken it so far that I’ve started  tracking it [in my human log](https://neilkakkar.com/the-human-log.html) - “Did I feel fear this week?” If the answer is no too many weeks in a row, I’ve gotten too comfortable.

我已经学会接受这种感觉。它让我兴奋。这是关于我将要学习的信息。到目前为止，我已经开始跟踪它 [在我的人类日志中](https://neilkakkar.com/the-human-log.html) - “这周我感到恐惧吗？”如果答案不是连续几周，我就太舒服了。


> Fear is information


> 恐惧就是信息

This meta skill of noticing what’s going on in the brain is a  powerful monitoring and diagnostic tool. Just like cron jobs that  periodically check the health of the system, [reviews check and improve](https://neilkakkar.com/year-in-review-2019.html) your health: mental and physical. That’s exactly the purpose of this post too: it’s my annual work review.

这种注意到大脑中发生的事情的元技能是一种强大的监控和诊断工具。就像定期检查系统健康状况的 cron 作业一样，[评论检查和改进](https://neilkakkar.com/year-in-review-2019.html) 你的健康：精神和身体。这也正是这篇文章的目的：这是我的年度工作回顾。

        !## Adding nuance

！## 添加细微差别

This review wouldn’t be complete without adding nuance to last years sections. [You can see last year’s here.](https://neilkakkar.com/things-I-learnt-from-a-senior-dev.html)

如果不对去年的部分添加细微差别，则此评论将是不完整的。 [你可以在这里看到去年的。](https://neilkakkar.com/things-I-learnt-from-a-senior-dev.html)

### Writing Code

### 编写代码

![img](https://neilkakkar.com/assets/images/SO_memes.jpg)

[Source](https://programmercave0.github.io/blog/2019/11/28/Memes-on-copy-pasting-code-from-Stackoverflow)

[来源](https://programmercave0.github.io/blog/2019/11/28/Memes-on-copy-pasting-code-from-Stackoverflow)

There’s this funny meme in software engineering which reduces things  down to copying from Stack Overflow. It’s a dangerous pattern when new  engineers start believing the meme. There’s a lot of things happening,  the nuance of which is lost when we say “copy from SO”.

软件工程中有一个有趣的模因，它可以将事情简化为从 Stack Overflow 复制。当新工程师开始相信模因时，这是一种危险的模式。发生了很多事情，当我们说“从 SO 复制”时，其中的细微差别就消失了。

Here’s an example of what copying from SO might look like. Let’s say I’m trying to list all permutations from a generator. Then:

以下是从 SO 复制的示例。假设我试图列出生成器的所有排列。然后：

1. This is not a coding interview, so I can look for libraries that do this for me. I don’t know what to use, yet.
2. I google it, and find I can use `itertools.permutations([1,2,3,4])` to generate permutations of a list.
3. Okay, golden! So now I convert the generator to a list, copy this code, and then pass the list in. I’m done.

1. 这不是编码面试，所以我可以寻找为我做这件事的图书馆。我还不知道该用什么。
2.我google了一下，发现可以使用`itertools.permutations([1,2,3,4])`来生成列表的排列。
3. 好的，金色！所以现在我将生成器转换为列表，复制这段代码，然后将列表传入。我就完成了。

Now, let’s say product requirements are to sort these in  lexicographic order. So I write a sort function that works on lists of  lists.

现在，假设产品要求是按字典顺序对它们进行排序。所以我编写了一个用于列表列表的排序函数。

Except, it doesn’t work. I find out that `permutations` returns a list of tuples, so I go back to my sorting function and convert it to work on list of tuples.

除了，它不起作用。我发现 `permutations` 返回一个元组列表，所以我回到我的排序函数并将它转换为处理元组列表。

A while later, product comes back with new requirements: these  permutations are too long, and we want to make things faster. We only  need permutations of length 4, no matter how big the list.

过了一会儿，产品又带着新的需求回来了：这些排列太长了，我们想让事情变得更快。无论列表有多大，我们只需要长度为 4 的排列。

Ugh. Okay. Since I already have a function for generating all  permutations, I do that and take the first 4 elements from each  permutation tuple. I realise this leads to duplicates, so I put these  tuples in a set, then apply the sorting function to get them in the  right order.

啊。好的。因为我已经有了一个生成所有排列的函数，所以我这样做并从每个排列元组中取出前 4 个元素。我意识到这会导致重复，所以我将这些元组放在一个集合中，然后应用排序功能以正确的顺序排列它们。

And now I’m done. Phew, this was hard work, but hey, everyone is sort of happy! The permutation function is still pretty slow for long lists, so I add an item in the backlog to get to it sometime. 

现在我完成了。呼，辛苦了，嘿嘿，大家都挺开心的！对于长列表，置换函数仍然很慢，所以我在 backlog 中添加了一个项目，以便在某个时候使用它。

If I had taken the time to check the documentation for `itertools.permutations`, to understand what it does, I would have noticed: it has a parameter  for the length of permutations you want to return. It returns a list of  tuples. And, it returns them in sorted order. Further, the input  argument is not a list, but an iterable, so I could’ve passed in the  generator. It was going to get converted [into a tuple anyway though](https://docs.python.org/3.7/library/itertools.html#itertools.permutations), so this doesn’t matter.

如果我花时间查看 `itertools.permutations` 的文档以了解它的作用，我会注意到：它有一个参数，用于表示您想要返回的排列长度。它返回一个元组列表。并且，它按排序顺序返回它们。此外，输入参数不是一个列表，而是一个可迭代的，所以我可以传入生成器。它会被转换[无论如何变成一个元组](https://docs.python.org/3.7/library/itertools.html#itertools.permutations)，所以这并不重要。

This example might seem trivial, but the thinking machinery behind it is not. I’ve noticed this almost happen to me with sufficiently complex APIs and misdirecting names.

这个例子可能看起来微不足道，但它背后的思维机制却并非如此。我注意到这种情况几乎发生在我身上，因为 API 足够复杂，名称也有误导性。

In short, my rule is “I don’t write code I don’t understand”. Just  like the “copy from SO” meme, this rule has tacit knowledge that gets  lost in translation. For example, what does it mean to understand code?

简而言之，我的原则是“我不写我不懂的代码”。就像“复制自 SO”模因一样，这条规则具有在翻译中丢失的隐性知识。例如，理解代码意味着什么？

There are at least three different levels of understanding: you might understand exactly what `itertools.permutations` would produce, you might understand how it does it, or at an even  deeper level, you might understand why it makes those implementation  decisions.

至少有三个不同层次的理解：你可能确切地理解`itertools.permutations` 会产生什么，你可能理解它是如何做到的，或者在更深的层次上，你可能理解它为什么做出这些实现决策。

Level 1 is understanding what the function or API does.
  Level 2 is understanding how it does it (the code).
  Level 3 is understanding why it does it the way it does.

级别 1 是了解函数或 API 的作用。
 第 2 级是理解它是如何做到的（代码）。
 第 3 级是理解为什么它会这样做。

For well designed APIs and things you don’t want to learn in depth, Level 1 works.

对于精心设计的 API 和您不想深入学习的东西，Level 1 有效。

However, Level 1 is the bare minimum. Level 0 is what we saw in the  example above, and it’s problematic. Another example is copying existing team templates for the first time, whic is somewhere between a level 0  and 1 understanding.

但是，级别 1 是最低要求。 0 级就是我们在上面的例子中看到的，这是有问题的。另一个例子是第一次复制现有的团队模板，这介于 0 级和 1 级理解之间。

Yes, there’s a trade-off. Level 0 is super quick, while getting to Level 3 takes a lot of time.

是的，有一个权衡。级别 0 非常快，而达到级别 3 需要很多时间。

I slow things down when I don’t copy paste existing templates. But when I have enough slack

当我不复制粘贴现有模板时，我会减慢速度。但是当我有足够的懈怠


, I choose to get a Level 1 understanding before I  write code. This usually means I’m slow the first time around, but over  time, I get much faster. I deepen my understanding a little bit every  time, and this helps me solve bugs quickly. I prioritise learning over  getting things done.


，我选择在写代码之前得到一个Level 1的理解。这通常意味着我第一次很慢，但随着时间的推移，我变得更快了。我每次都加深了一点理解，这有助于我快速解决错误。我优先考虑学习而不是完成任务。

And, yes, I do break the rule sometimes. Some situations demand a quick and easy hack.

而且，是的，我有时确实违反了规则。有些情况需要快速简单的破解。

        !Sometimes, open-source documentation sucks. When this happens, you  need a level 2 understanding to give you the level 1 understanding: you  go read the source code. Whenever I have to do this, I remember to **preserve context for future-me**. It’s hard work to understand someone else’s code, specially if it’s in a language you’re not familiar with. Optimise for not having to do this  hard work again and again. When you figure out something important,  write it down - that’s what comments are for. Plus, your team will thank you for it. It’s an easy way to build up the force multiplier.

！有时，开源文档很糟糕。发生这种情况时，您需要有 2 级理解才能获得 1 级理解：您可以阅读源代码。每当我必须这样做时，我记得**为未来的我保留上下文**。理解别人的代码是一项艰巨的工作，尤其是当它使用您不熟悉的语言时。优化不必一次又一次地完成这项艰苦的工作。当你发现一些重要的事情时，把它写下来——这就是评论的作用。另外，您的团队会为此感谢您。这是建立力乘数的简单方法。

This is a lot like “saving” information packets. They’re units of  work you’ve already done, so you don’t do them again the next time.

这很像“保存”信息包。它们是你已经完成的工作单元，所以你下次不要再做它们了。

The levels of understanding apply to the code your team owns as well, not just code you copy paste, or ‘inherit’ from others. Ideally, you  ought to have a level 2 understanding of your team’s code, and a level 3 understanding of code you own. This understanding is building a [mental model](https://neilkakkar.com/A-Simplistic-explanation-to-Mental-Models.html) of how the code works. 

理解水平也适用于您的团队拥有的代码，而不仅仅是您复制粘贴或“继承”他人的代码。理想情况下，您应该对团队的代码有 2 级理解，对您拥有的代码有 3 级理解。这种理解正在构建代码如何工作的 [心理模型](https://neilkakkar.com/A-Simplistic-explanation-to-Mental-Models.html)。

I’ve noticed that code reviews help a lot in building this mental  model. I do as many reviews as I can: it keeps me in the loop for what  my team is working on. There’s also a very interesting [feedback mechanism](https://neilkakkar.com/How-to-see-Systems-in-everyday-life.html) built in to this. I can judge how well I understand the code by my  review comments. The less familiar I am with the code base, the more  trivial my comments. As my mental model improves, I start seeing the  system as a whole and how this new part will interact with everything  else. I can spot inconsistencies, and figure out when something wouldn’t work. When I start making comments like these, I know I’m inching  towards a level 2-3 understanding.

我注意到代码审查对构建这种心理模型有很大帮助。我做尽可能多的评论：它让我了解我的团队正在做的事情。还有一个非常有趣的 [反馈机制](https://neilkakkar.com/How-to-see-Systems-in-everyday-life.html) 内置于此。我可以通过我的评论来判断我对代码的理解程度。我对代码库越不熟悉，我的评论就越琐碎。随着我的心智模型的改进，我开始将系统视为一个整体，以及这个新部分将如何与其他一切交互。我可以发现不一致之处，并找出什么时候不起作用。当我开始发表这样的评论时，我知道我正在逐步达到 2-3 级的理解。

Since the code is always evolving, this is a constant process: your  understanding can go up and down depending on how out of touch you get.

由于代码总是在不断发展，因此这是一个持续的过程：您的理解可能会根据您的脱节程度而上下波动。

Another reason to get a level 2-3 understanding is to seek  inspiration. When you understand the code of a new system, you figure  out what decisions they made, and why. This increases your repertoire of things to work with

获得 2-3 级理解的另一个原因是寻求灵感。当你理解一个新系统的代码时，你就会弄清楚他们做了什么决定，以及为什么。这增加了您要处理的事物的曲目


. This is one big reason why I dived into Unix, and [wrote about how it works](https://neilkakkar.com/unix.html). This is also a very good reason to understand the tools you use, which is why I [learned how Git works](https://neilkakkar.com/How-not-to-be-afraid-of-GIT-anymore.html)


.这是我深入研究 Unix 并[撰写有关其工作原理的文章](https://neilkakkar.com/unix.html) 的一大原因。这也是理解你使用的工具的一个很好的理由，这就是为什么我 [学习了 Git 是如何工作的](https://neilkakkar.com/How-not-to-be-afraid-of-GIT-anymore.html)

To summarize:

总结一下：

1. Don’t write code you don’t understand
2. Prioritise learning whenever possible
3. Preserve context for future you
4. Aim for a level 2-3 understanding of code your team owns
5. Code reviews help keep your mental models up to date

1.不要写你不懂的代码
2. 尽可能优先学习
3. 为未来的你保留背景
4. 力争对团队拥有的代码有 2-3 级的理解
5. 代码审查有助于让你的心智模型保持最新

### Testing

### 测试

Say you build a new system, and testing reveals it to be too slow. You designed it considering how long each component would take, but  looks like some of your assumptions failed you. What’s the next thing  you do?

假设您构建了一个新系统，测试表明它太慢了。你设计它时考虑了每个组件需要多长时间，但看起来你的一些假设失败了。你下一步做什么？


I would measure how long each component takes to identify where I can make the biggest impact. Some things are indeed out of your control,  like the request latency. You’re probably not going to launch a  satellite to make your code faster. Measuring timing and figuring out  where you can improve is critical.


我会衡量每个组件需要多长时间来确定我可以在哪些方面产生最大影响。有些事情确实超出了您的控制，例如请求延迟。你可能不会发射卫星来让你的代码更快。衡量时机并找出可以改进的地方至关重要。

I’ve tried going in guns blazing, optimising whatever looks  suboptimal to me, like converting dicts to sets - but the final solution is usually never this obvious. Dicts are probably not the reason your  request is taking a second longer.

我试过大刀阔斧，优化对我来说看起来不理想的任何东西，比如将字典转换为集合 - 但最终的解决方案通常从来没有这么明显。字典可能不是您的请求需要更长的时间的原因。


> Measure instead of assuming.


> 测量而不是假设。

        !In last year’s review, I wrote:

！在去年的评论中，我写道：

> If there’s an environment mismatch between test and deploy  machines, you’ll be in trouble. And here’s where deployment environments come in. […] The idea is to try and catch errors that unit and system  testing wouldn’t. For example, an API mismatch between requesting and  responding system.

> 如果测试和部署机器之间存在环境不匹配，你会遇到麻烦。这就是部署环境的用武之地。 [...] 这个想法是尝试捕捉单元和系统测试不会的错误。例如，请求和响应系统之间的 API 不匹配。

I didn’t quite appreciate a clean testing environment until it bit  me. By clean, I mean it replicates your prod environment completely. It  allows you to test exactly what will happen in prod. Of course, you  don’t need a physical machine, docker works well here.

在它咬我之前，我不太喜欢干净的测试环境。干净，我的意思是它完全复制了您的产品环境。它允许您准确测试生产中会发生什么。当然，你不需要物理机，docker在这里运行良好。

I’ve found docker to be one of the biggest productivity tools for  testing. It allows me to whip up new environments, test things locally,  and reduces friction. This fast feedback loop allows me to develop  quicker. It’s frustrating when I have to wait 5-10 minutes to check if I deployed well, trigger a test, check outputs, etc. Docker is all of  that, right on my machine.

我发现 docker 是最大的测试生产力工具之一。它使我能够创建新环境、在本地测试事物并减少摩擦。这种快速的反馈循环使我能够更快地开发。当我必须等待 5-10 分钟来检查我是否部署良好、触发测试、检查输出等时，这令人沮丧。 Docker 就是所有这些，就在我的机器上。

One final thing I learned was to optimise for zero false positives. It’s easy to write tests that pass without testing what you intended to. For example, iterating through a database cursor and checking the  values? Well if the iterator returns nothing, your test has passed  without checking anything. 

我学到的最后一件事是优化零误报。编写通过而无需测试您想要的测试很容易。例如，遍历数据库游标并检查值？好吧，如果迭代器不返回任何内容，则您的测试已通过而没有检查任何内容。

These are false positives, and they’re sinister for giving you a  false sense of confidence. How do I fix these? Well, I start by being  extra careful during code reviews. The second, sure-fire way of testing  this is to make your tests fail. I switch around an equals to a  not-equals. If tests still pass, I have a problem. This is something  I’ve started doing recently, once I saw my first false positive.

这些都是误报，它们会给你一种错误的自信感。我该如何解决这些问题？好吧，我首先在代码审查期间格外小心。第二种，万无一失的测试方法是让你的测试失败。我将等于号转换为不等于号。如果测试仍然通过，我有问题。这是我最近开始做的事情，一旦我看到我的第一个误报。

In summary:

总之：

1. With optimisation problems, measure instead of assuming.
2. Have a clean staging environment. Containerisation is cool.
3. Optimise for 0 false positives.

1. 对于优化问题，测量而不是假设。
2. 有一个干净的暂存环境。集装箱化很酷。
3. 针对 0 误报进行优化。

### Design

###  设计

Almost every system design is about trade-offs. The good engineers make these trade-offs explicit.

几乎每一个系统设计都是关于权衡的。优秀的工程师会明确地做出这些权衡。

These trade-offs rise out of the constraints on us and on the product we want.

这些权衡源于对我们和我们想要的产品的限制。

Speaking of, requirements and constraints are not the same. Constraints are real world limits. For example, we can’t send messages  from New York to Australia in 1 millisecond, yet. There are also product constraints, like we don’t want users to see more than 3 pop ups any  time.

说起来，需求和约束是不一样的。约束是现实世界的限制。例如，我们还不能在 1 毫秒内从纽约向澳大利亚发送消息。还有产品限制，比如我们不希望用户在任何时候看到超过 3 个弹出窗口。

Requirements, on the other hand, are flexible. They are things we  want to happen, but often times we don’t know what we want. Asking  myself “what am I really trying to do?” helps uncover the constraints  from the requirements. Usually, people jump too quickly into the  requirements - which is just one of the many possible paths from the  constraints. So, whenever I feel the requirements don't make sense, I go back the constraints and [reason up to reach alternative requirements.](https://neilkakkar.com/A-framework-for-First-Principles-Thinking.html) I learned to do this from my PM - he's excellent! - and from [@shreyas](https://twitter.com/shreyas) Twitter threads.

另一方面，要求是灵活的。它们是我们想要发生的事情，但很多时候我们不知道我们想要什么。问问自己“我真正想要做什么？”有助于从需求中发现约束。通常，人们过快地进入需求——这只是限制的众多可能途径之一。因此，每当我觉得这些要求没有意义时，我就会回到约束条件和 [达到替代要求的理由。](https://neilkakkar.com/A-framework-for-First-Principles-Thinking.html) 我从我的 PM 那里学会了这样做 - 他很棒！ - 来自 [@shreyas](https://twitter.com/shreyas) Twitter 线程。


> There’s no holy grail design that will always work


> 没有永远有效的圣杯设计

When designing systems, I’ve noticed two broad themes.

在设计系统时，我注意到了两个广泛的主题。

The first is that there are a limited number of components we’ve  invented: queues, caches, databases, and connectors (or code to make  them work together). Every possible design is a permutation of these  components - each of which present their own trade-offs. Some are much  faster, some are much more maintainable, and some are much more  scalable, depending on your use-case.

首先是我们发明的组件数量有限：队列、缓存、数据库和连接器（或使它们协同工作的代码）。每个可能的设计都是这些组件的排列——每个组件都有自己的权衡。有些更快，有些更易于维护，有些更具可扩展性，具体取决于您的用例。

Given your constraints, one arrangement will be better than the  other. Your goal is finding that arrangement. From time to time, there  are brilliant hacks you can do to reduce complexity, or make things  faster. However, the basic infrastructure doesn’t change.

鉴于您的限制，一种安排会比另一种更好。你的目标是找到这种安排。有时，您可以通过一些绝妙的技巧来降低复杂性或加快速度。然而，基本的基础设施并没有改变。

The second is that everyone has a few happy-themes to go back to,  which they’ve seen work well in the past. These are different lenses to  look at the system. Design is about figuring out which permutations  conform to this lens.

第二个是每个人都有一些快乐的主题可以回顾，他们过去认为这些主题运作良好。这些是观察系统的不同镜头。设计就是要弄清楚哪些排列符合这个镜头。

For example, I love reducing state and keeping things simple. Reducing state helps me reason better about systems, and helps me write  better tests. Same for keeping things simple. Both lead to fewer bugs. Of course, it can’t be too simple: it can’t violate the constraints.

例如，我喜欢减少状态并保持简单。减少状态有助于我更好地推理系统，并帮助我编写更好的测试。同样是为了让事情变得简单。两者都会导致更少的错误。当然，也不能太简单：不能违反约束。

Like I said last year, it’s worth thinking about speed, as well as  local development and testing. If two designs are equivalent, but one is much easier to setup locally and write tests for, I’ll almost always  choose the one that’s easier to write tests for.

就像我去年所说的，值得考虑速度以及本地开发和测试。如果两种设计是等效的，但一种更容易在本地设置并为其编写测试，我几乎总是选择更容易为其编写测试的一种。

I like figuring out other people’s lenses, and try to adopt lenses I don’t have. That’s another reason I read tech blogs.

我喜欢弄清楚别人的镜头，并尝试采用我没有的镜头。这是我阅读技术博客的另一个原因。

When designing, it’s worth preserving context too, just like when  writing code. Often times, I’ve seen myself come back to very old code,  forget the assumptions we had then, and think “Wtf, why did we do it  like this?!”. Making our constraints and trade-offs explicit helps keep  things in perspective, and helps judge whether you made the right  decision.

在设计时，保留上下文也是值得的，就像在编写代码时一样。很多时候，我看到自己回到非常旧的代码，忘记我们当时的假设，并想“哇，我们为什么要这样做？！”。明确我们的约束和权衡有助于保持正确的观点，并有助于判断您是否做出了正确的决定。

Finally, when designing systems that replace existing systems, I find it very important to talk about the migration paths: How will we manage moving from the old system to new system? 

最后，在设计替换现有系统的系统时，我发现谈论迁移路径非常重要：我们将如何管理从旧系统到新系统的迁移？

If you’ve ever noticed a system with half of the things running on  the new code, and half on the old code, that’s a flawed migration path. Not thinking about the migration path leads to mounting tech debt: you  now have to manage and maintain both the new and the old systems. Sometimes, this happens because priorities switch, and you’re left in  the middle. In either case, these abnormalities don’t age well.

如果您曾经注意到一个系统，其中一半运行在新代码上，另一半运行在旧代码上，那么这是一条有缺陷的迁移路径。不考虑迁移路径会导致越来越多的技术债务：您现在必须管理和维护新旧系统。有时，发生这种情况是因为优先级发生了变化，而您被留在了中间。在任何一种情况下，这些异常都不会老化。

Good migration paths that might take longer than a sprint take into  account the state they leave the system in. If priorities change, will  we get stuck in a state where we can’t do anything? Or is our migration  incremental, which is robust to changing priorities? Of course, the  incremental migration isn’t always the right solution. Sometimes, the  clean break is a lot easier. The important part there is communicating  well: we can’t deal with changing priorities for this migration.

可能比 sprint 花费更长时间的良好迁移路径会考虑他们离开系统的状态。 如果优先级发生变化，我们是否会陷入无法做任何事情的状态？还是我们的迁移是渐进式的，这对不断变化的优先事项很有效？当然，增量迁移并不总是正确的解决方案。有时，干净的休息要容易得多。重要的部分是良好的沟通：我们无法应对此次迁移的优先级不断变化。

In summary:

总之：

1. Every system design is about trade-offs.
2. There’s limited technical components to every design.
3. People have definite lenses with which they approach design, just like mental models.
4. Preserve context when designing: write down your constraints and trade-offs.
5. When replacing old systems, have a clear migration path.

1. 每个系统设计都是权衡取舍。
2. 每个设计都有有限的技术组件。
3. 就像心智模型一样，人们有明确的视角来进行设计。
4. 在设计时保留上下文：写下你的限制和权衡。
5、更换旧系统时，要有清晰的迁移路径。

#### Gathering Requirements

#### 收集要求

Going with the above theme, gathering requirements is actually  gathering constraints. Like we saw above, requirements are sometimes a  translation of the constraints into tech requirements, which isn’t  always the way to go forward.

与上述主题一致，收集需求实际上就是收集约束。就像我们在上面看到的那样，需求有时是将约束转化为技术需求，这并不总是前进的方式。

In my team culture, there’s enough trust in both the team and the PM  that we’re free to challenge each other on this. Asking the question  suffices.

在我的团队文化中，对团队和 PM 都有足够的信任，我们可以在这方面自由地相互挑战。问这个问题就够了。

A checklist of questions works well here. [Here are some questions I ask frequently](https://neilkakkar.com/requirements-checklist.html)

问题清单在这里很有效。 [这里有一些我经常问的问题](https://neilkakkar.com/requirements-checklist.html)

        !This final section dives into a few gotchas, some things I did wrong, and a summary of everything that went right.

！这最后一部分深入探讨了一些问题，我做错了一些事情，以及所有正确的事情的总结。

## Some hacks that have worked very well for me

## 一些对我来说效果很好的黑客

- Doing as many code reviews as possible. The more you miss, the  wronger your mental model for the code becomes, and the more time it  takes you to figure out how to design the new thingy.
- Playing the meta: An important second question to ask is “How did  you find out X?”, where X is the answer to your first question.
- The first person to review my PRs is… me. Always. I like doing  this a lot. It’s something I learned from writing: The first phase is  writing out the substance, the second phase is editing for flow. It’s  similar in code. Code review is the edit phase, and doing this on my  code makes me better at writing code, noticing inconsistencies, and  figuring out how others would approach the review.

- 进行尽可能多的代码审查。你错过的越多，你对代码的心理模型就越错误，你花更多的时间来弄清楚如何设计新事物。
- 玩元：要问的第二个重要问题是“您是如何找到 X 的？”，其中 X 是您第一个问题的答案。
- 第一个审查我的 PR 的人是……我。总是。我非常喜欢这样做。这是我从写作中学到的东西：第一阶段是写出实质，第二阶段是编辑流。代码上类似。代码审查是编辑阶段，对我的代码执行此操作可以让我更好地编写代码、注意不一致之处并弄清楚其他人将如何进行审查。

## Super powers

## 超能力

Just like in a video game, there are a few power ups you can obtain. These help give you powers in the real world. Just like in a video game, you need to go on quests to obtain them.

就像在电子游戏中一样，您可以获得一些能量提升。这些帮助赋予你在现实世界中的力量。就像在电子游戏中一样，您需要进行任务才能获得它们。

Here are a few I’ve discovered, and possible quests to get them through.

以下是我发现的一些，以及让它们通过的可能任务。

- Getting into the source code when documentation isn’t enough     - Quest: Reading open source code.

- 在文档不够的情况下进入源代码 - 任务：阅读开源代码。

- Quickly build a mental model for the code you’re looking at     - Quest: Reading open source code.

- 快速为您正在查看的代码建立一个心智模型 - 任务：阅读开源代码。

- Embracing fear     - Quest: Build a side project.

- 拥抱恐惧 - 任务：建立一个副项目。

- Confidence to express ignorance     - Quest: Overcome the first gotcha with growing.

- 表达无知的信心 - 任务：克服成长中的第一个陷阱。

- Defining my terms. Letting people know exactly what I’m talking about. Like I mentioned in an  Idea Muse

    - 定义我的条款。让人们确切地知道我在说什么。就像我在 Idea Muse 中提到的

   article a few weeks ago:  “Most of the time, most people don’t know what they’re talking about.”

   几周前的文章：“大多数时候，大多数人不知道他们在说什么。”

  - Quest: ???

- 任务：？？？

## Some gotchas with growing

## 成长中的一些问题

Just as engineers appreciate documentation that includes common  gotchas, I think people appreciate reading about common gotchas with  growing - mistakes I noticed myself making, and then corrected.

就像工程师喜欢包含常见问题的文档一样，我认为人们也喜欢阅读有关不断增长的常见问题 - 我注意到自己犯的错误，然后更正了。

### Sometimes, I feel I need to know the answer to everything

### 有时候，我觉得我需要知道一切的答案

As I figure out more things, more people reach out to me with  questions. This feels great! However, there are bound to be questions I  don’t know the answer to. In this case, chasing the feeling, and  feigning intelligence is a trap. A trap that stops me from learning.

随着我弄清楚更多的事情，更多的人向我提出问题。这感觉很棒！然而，肯定会有一些我不知道答案的问题。在这种情况下，追逐感情，假装聪明就是一个陷阱。一个阻止我学习的陷阱。

Will people stop coming to me if I say I don’t know? Probably not.

如果我说我不知道，人们会不会不再来找我？可能不是。

Further, they’re going to find out the answer anyway, since they’re  competent and smart too. How dumb would it be to not soak in that  knowledge too?

此外，他们无论如何都会找到答案，因为他们也能干和聪明。不沉浸在这些知识中会有多愚蠢？

Confidence to express ignorance is a super power. 

自信地表达无知是一种超能力。

One good way I hone this skill is by saying “Nothing to add” when I  have nothing to add, instead of repeating what other people said. It  feels powerful to me. I got this one [from Charlie Munger.](https://neilkakkar.com/Psychology-of-Human-Misjudgment.html)

我磨练这项技能的一个好方法是在我没有什么可补充的时候说“没什么可补充的”，而不是重复别人说的话。对我来说感觉很强大。我从查理芒格那里得到了这个。](https://neilkakkar.com/Psychology-of-Human-Misjudgment.html)

### Sometimes, I lose my cool

### 有时，我失去了冷静

There are some times when I enter the panic & frustration mode. I stop reasoning about things rationally and write whatever garbage I can to solve the problem. Add a call, add a bracket, print random stuff,  just get things to run *some way*. This usually starts when it takes me longer than expected to fix something.

有时我会进入恐慌和沮丧模式。我不再理性地推理事情，写尽我所能解决问题的垃圾。添加一个调用，添加一个括号，打印随机的东西，只是让事情以某种方式运行*。这通常是在我修复某事所需的时间比预期更长时开始的。

Here’s a concrete example. I was working on tests for a new queue  system we built, and I wanted to simulate starving and competing queue  consumers. So, I decided to spawn several threads in the test, all  running the consumer, which would run for 5 seconds, competing for one  single message in the queue. I’d expect only one of them to get the  message (that’s the queue semantics we implemented). And I’d expect none of them to crash.

这是一个具体的例子。我正在为我们构建的新队列系统进行测试，我想模拟饥饿和竞争队列消费者。因此，我决定在测试中生成多个线程，所有线程都运行消费者，它将运行 5 秒，竞争队列中的一条消息。我希望只有其中一个能得到消息（这是我们实现的队列语义）。我希望它们都不会崩溃。

For the test, I `join`ed the  threads with a timeout of 5 seconds. These tests didn’t seem to work. I  tried simulating things manually, and everything would work as expected. But with the threads, sometimes the tests would fail. I couldn’t figure this out. I tried every random thing I could. In one great moment of  desperation, I re-ordered the tests. It felt funny doing this, how could this possibly help? Turns out, the first test passed again, and the  other one, which was passing beforehand started failing.

为了测试，我以 5 秒的超时“加入”线程。这些测试似乎不起作用。我尝试手动模拟事物，一切都会按预期进行。但是对于线程，有时测试会失败。我想不通。我尝试了所有我能做的随机事情。在一个非常绝望的时刻，我重新订购了测试。这样做感觉很有趣，这怎么可能有帮助？事实证明，第一个测试再次通过，而另一个之前通过的测试开始失败。

This is when I noticed I had lost my cool, trying random things that  didn’t make sense. I calmed down, and started investigating what was  happening in the threads. Turns out, `join` just waits, and doesn’t kill the process even after timeout. `terminate()` is what kills the process. If I had taken the time to read the docs properly, I wouldn’t have felt so frustrated.

就在这时，我注意到我失去了冷静，尝试了一些没有意义的随机事情。我冷静下来，开始调查线程中发生的事情。事实证明，`join` 只是等待，即使超时后也不会终止进程。 `terminate()` 是杀死进程的原因。如果我花时间正确阅读文档，我就不会感到如此沮丧。

The threads weren’t being terminated, and these orphans would mess with the following tests.

线程没有被终止，这些孤儿会干扰以下测试。

Usually, this happens when I’m in a rush, when I haven’t protected my slack, and as a result I’m not prioritising learning over doing. Other  times, it’s because it’s a hard piece of code, and no low-hanging fruit  solved the problems.

通常，这种情况发生在我匆忙时，当我没有保护自己的懈怠时，因此我不会优先考虑学习而不是做。其他时候，是因为它是一段很难的代码，而且没有什么容易解决的问题。

Noticing I’m doing this is usually enough to snap me out of it. I move from ad-hoc bug fixing to strategic bug fixing.

注意到我这样做通常足以让我摆脱它。我从临时错误修复转向战略性错误修复。

### Neophilia

### 恋童癖

It’s easy to take optimising learning over doing too far. For  example, making the wrong design decisions to try out a new technology. I keep myself in check thanks to our team culture. We challenge each  other’s decisions, and realise when we have no good reason to explain  it, there’s a latent desire - which we then make explicit.

优化学习而不是做得太远很容易。例如，为了尝试新技术而做出错误的设计决策。多亏了我们的团队文化，我才能控制自己。我们挑战彼此的决定，并意识到当我们没有充分的理由解释它时，有一种潜在的愿望——然后我们将其明确化。

A concrete way I do this: When figuring out pros and cons for a  design, I explicitly mention “this would be cool to learn”, so this  desire stops hiding behind flimsy reasons.

我这样做的具体方法：在确定设计的利弊时，我明确提到“这会很酷”，因此这种愿望不再隐藏在脆弱的理由后面。

> Make decisions for the right reasons, not to try something new out

> 以正确的理由做出决定，而不是尝试新事物

Adding a new technology to the team stack is a big decision, one not to be taken lightly.

向团队堆栈添加一项新技术是一个重大决定，不能掉以轻心。

        !## Questions

！## 问题

To extend last year’s list, there are a few questions I don’t yet have the answer to.

为了扩大去年的名单，有几个问题我还没有答案。


  I’d like to think more about these this year.


 今年我想更多地考虑这些。

1. How do you build a culture which promotes X, Y, Z?
2. How do you judge culture fit? Hard to do top-down predictions when things are built bottom up.
3. I suspect being precise with your words is yet another super  power. It’s effective communication + communicating the right thing. What’s one quest I can do to hone this?
4. What are some open problems in software engineering?

1. 你如何建立一种促进 X、Y、Z 的文化？
2. 你如何判断文化契合度？当事物自下而上构建时，很难进行自上而下的预测。
3. 我怀疑言辞准确是另一种超能力。这是有效的沟通+传达正确的事情。我可以做些什么来磨练这一点？
4. 软件工程中有哪些未解决的问题？

and some questions from last year that I’d still like to think about

以及去年我还想思考的一些问题

1. How to deal with documentation for code and workflows?
2. Explore De-risking further. What all strategies exist to de-risk projects?
3. How to decrease rate of system degradation? 

1. 如何处理代码和工作流的文档？
2. 进一步探索去风险化。存在哪些降低项目风险的所有策略？
3. 如何降低系统退化率？

        !My first year was all about absorbing all I could. I didn’t know  enough to see the system, I could only see the parts. This year, I took a gods eye view to the system. I figured out places where I was  suboptimal and worked on those. I looked at other parts of the system,  absorbed their best practices, and become wary of practices that didn’t  work for me.

！我的第一年就是吸收所有我能做的。我不太了解系统，我只能看到零件。今年，我对系统进行了上帝视角。我找出了我不理想的地方并进行了研究。我查看了系统的其他部分，吸收了他们的最佳实践，并对不适合我的实践保持警惕。

Over time I started looking inward for things I’m doing right, and  before I knew it, others started seeing me as a senior software  engineer.

随着时间的推移，我开始向内寻找我做对的事情，在我意识到之前，其他人开始将我视为高级软件工程师。


Damn, I love engineering.


该死的，我喜欢工程。

        !If you’re looking for a summary to remember this post by, read [software engineering skills.](https://neilkakkar.com/senior-software-engineer-summary.html)

！如果您正在寻找总结来记住这篇文章，请阅读 [软件工程技能。](https://neilkakkar.com/senior-software-engineer-summary.html)

> Thanks to Hung for reading drafts of this.

> 感谢 Hung 阅读本文的草稿。

1. Also, probably the first thing I learned this year was to use  the American spelling of 'learned' (not 'learnt'), since most readers  are from the States and some of them [freaked out on HN and Reddit](https://news.ycombinator.com/item?id=20796159) when they saw 'learnt'. Funny. [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:2)
2. I haven’t stopped learning about these, I’ve just taken different approach. More on this in [acquiring new tools for thought](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#acquiring-new-tools-for-thought--mental-models). [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:3)
3. My interpretation, not representing my employers. Same for the entire article. [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:15)
4. Except for a few system inefficiencies. [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:1)
5. Affiliate link [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:25)
6. Like when you know exactly what you’re doing and you’ve done it a few times before. [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:11)
7. Just communicating is probably not enough in certain team  cultures. I haven’t been a part of one like this yet, so I don’t know  how to help there. [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:16)
8. Again, caveats apply. For example, having slack is not an  excuse to go fix that damn bug that irritates you - that’s a proper  story / KTLO item. There are good and bad ways to use up your slack. I  prefer using slack for understanding depth of the current issue / new  tech / etc. [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:5)
9. Read more: Julia Evans on [asking good questions.](https://jvns.ca/wizard-zine.pdf) [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:18)
10. One way to hack this would be to start getting fearful of the  smallest things, but I’ve never been able to control what I’m afraid of, so I think I’m safe here. [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:9)
11. read: I can protect my slack [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:8)
12. Tools for thought! [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:19)
13. Not rhetorical, I’d love to hear from you! [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:4)
14. Not usually, anyway. [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:7)
15. You should go follow Shreyas! [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:10)
16. After all, [questions are more important than answers](https://neilkakkar.com/year-in-review-2019.html#questions-are-more-important-than-answers).[↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:20)
17. No, I don’t have the title yet. [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:21)

1. 另外，可能我今年学到的第一件事是使用“learned”（不是“learnt”）的美式拼写，因为大多数读者来自美国，其中一些人[对 HN 和 Reddit 感到害怕](https://news.ycombinator.com/item?id=20796159) 当他们看到 'learnt' 时。有趣的。 [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:2)
2.我没有停止学习这些，我只是采取了不同的方法。在 [获取新的思考工具](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#acquiring-new-tools-for-thought--心理模型)。 [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:3)
3. 我的解释，不代表我的雇主。整篇文章也一样。 [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:15)
4. 除了少数系统效率低下。 [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:1)
5. 附属链接 [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:25)
6. 就像你确切地知道自己在做什么并且之前已经做过几次一样。 [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:11)
7. 在某些团队文化中，仅仅沟通可能是不够的。我还没有成为这样的人的一部分，所以我不知道如何在那里提供帮助。 [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:16)
8. 再次提醒注意。例如，松懈并不是去修复那个让你恼火的该死的错误的借口——这是一个正确的故事/KTLO 项目。有好的和坏的方法来消耗你的余力。我更喜欢使用 slack 来理解当前问题/新技术等的深度[↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:5)
9. 阅读更多：Julia Evans 关于 [提出好的问题](https://jvns.ca/wizard-zine.pdf) [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:18)
10. 解决这个问题的一种方法是开始害怕最小的事情，但我一直无法控制我害怕的东西，所以我认为我在这里很安全。 [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:9)
11.阅读：我可以保护我的懈怠[↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:8)
12. 思考工具！ [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:19)
13. 不是修辞，我很想听听你的意见！ [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:4)
14. 无论如何，通常不会。 [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:7)
15.你应该去跟随Shreyas！ [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:10)
16. 毕竟，[问题比答案更重要](https://neilkakkar.com/year-in-review-2019.html#questions-are-more-important-than-answers)。[↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:20)
17. 不，我还没有头衔。 [↩](https://neilkakkar.com/things-I-learned-to-become-a-senior-software-engineer.html#fnref:21)

### You might also like

###  你可能还喜欢

- [Funnels: The One Big Mental Model from Sales & Marketing](https://neilkakkar.com/funnels-mental-model.html) 

- [漏斗：来自销售和营销的一个大心理模型](https://neilkakkar.com/funnels-mental-model.html)

- [Building your own Hey email Feed in Gmail](https://neilkakkar.com/gmail-hey-feed.html)
- [Debugging Interesting Bugs at PostHog](https://neilkakkar.com/debugging-open-source.html)
- [Why Is Naming Things Hard?](https://neilkakkar.com/why-is-naming-things-hard.html) 

- [在 Gmail 中构建您自己的 Hey 电子邮件 Feed](https://neilkakkar.com/gmail-hey-feed.html)
- [在 PostHog 调试有趣的错误](https://neilkakkar.com/debugging-open-source.html)
- [为什么命名很难？](https://neilkakkar.com/why-is-naming-things-hard.html)

